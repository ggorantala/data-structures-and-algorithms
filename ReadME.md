# Data Structures and Algorithms

## Overview

This repository is a comprehensive guide to Data Structures and Algorithms (DSA), aimed at providing foundational knowledge as well as advanced concepts. It includes a variety of algorithms and data structures, with explanations, use cases, and implementations in multiple programming languages (primarily in Java). The focus is on helping learners and professionals improve their understanding of DSA, which is crucial for technical interviews and efficient software development.

## Table of Contents
1. Introduction
2. Data Structures
   - Arrays 
   - Linked Lists 
   - Stacks 
   - Queues 
   - Trees
   - Graphs
   - Heaps
   - Hash Tables
3. Algorithms 
   - Sorting Algorithms 
   - Searching Algorithms 
   - Dynamic Programming 
   - Greedy Algorithms 
   - Divide and Conquer 
   - Backtracking
4. Complexity Analysis 
   - Big O Notation 
   - Time Complexity
   - Space Complexity
5. Common Interview Questions
6. Contributing
7. License

## Introduction
Data Structures and Algorithms form the backbone of computer science and software development. Understanding these concepts allows developers to write efficient, optimized, and scalable code. This repository covers various data structures and algorithms, providing clear explanations and code samples for each.

## Data Structures
### Arrays
- **Definition**: A collection of elements identified by index or key.
- **Use Cases**: Suitable for quick lookups and iteration.
- **Operations**: Insertion, deletion, traversal, searching.
- **Examples**: One-dimensional array, two-dimensional arrays.

### Linked Lists
- **Definition**: A linear collection of nodes, where each node points to the next node.
- **Types**: Singly Linked List, Doubly Linked List, Circular Linked List.
- **Use Cases**: Dynamic memory allocation, implemented in situations where frequent insertions and deletions occur.

### Stacks
- **Definition**: A collection that follows the Last In First Out (LIFO) principle.
- **Use Cases**: Function calls, undo operations in editors, parentheses checking.
- **Operations**: Push, Pop, Peek.

### Queues
- **Definition**: A collection that follows the First In First Out (FIFO) principle.
- **Use Cases**: Scheduling processes, managing requests in systems.
- **Types**: Simple Queue, Circular Queue, Priority Queue, Deque.

### Trees
- **Definition**: A hierarchical data structure consisting of nodes connected by edges.
- **Types**: Binary Tree, Binary Search Tree, AVL Tree, Red-Black Tree, B-Trees.
- **Use Cases**: Organizing hierarchical data, efficient searching, and sorting.

### Graphs
- **Definition**: A collection of nodes (vertices) connected by edges.
- **Types**: Directed, Undirected, Weighted, Unweighted.
- **Use Cases**: Social networks, navigation systems, dependency resolution.

### Heaps
- **Definition**: A specialized tree-based data structure that satisfies the heap property.
- **Types**: Max-Heap, Min-Heap.
- **Use Cases**: Priority queues, sorting algorithms (Heap Sort).

### Hash Tables
- **Definition**: A data structure that maps keys to values using a hash function.
- **Use** **Cases**: Fast lookups, database indexing.
- **Operations**: Insertion, deletion, search, collision resolution.

## Algorithms
### Sorting Algorithms
- **Bubble Sort**: Repeatedly swaps adjacent elements if they are in the wrong order.
- **Merge Sort**: A divide-and-conquer algorithm that splits the array in half, sorts each half, and merges them.
- **Quick Sort**: Picks a pivot and partitions the array such that elements smaller than the pivot go to one side and those larger go to the other.
- **Heap Sort**: Utilizes a heap data structure to sort elements.

### Searching Algorithms
- **Linear Search**: Sequentially checks each element until the target is found.
- **Binary Search**: Divides the array in half and eliminates half of the search space after each comparison (requires sorted data).

### Dynamic Programming
- **Definition**: A method for solving problems by breaking them down into simpler subproblems, storing the results to avoid redundant calculations.
- **Examples**: Fibonacci sequence, Knapsack problem.

### Greedy Algorithms
- **Definition**: Builds up a solution piece by piece, always choosing the next piece that offers the most immediate benefit.
- **Examples**: Dijkstra's shortest path algorithm, Huffman coding.

### Divide and Conquer
- **Definition**: Solves problems by dividing them into smaller subproblems, solving each independently, and combining their results.
- **Examples**: Merge Sort, Quick Sort, Binary Search. 

### Backtracking
- **Definition**: A brute-force search algorithm that tries all possibilities and backtracks when a solution is deemed unfit.
- **Examples**: N-Queens problem, Sudoku solver.

## Complexity Analysis
- **Big O Notation**: Describes the upper bound of the time or space complexity in terms of the input size.
- **Time Complexity**: Best Case, Average Case, Worst Case scenarios for each algorithm.
- **Space Complexity**: Memory usage of the algorithm, which includes the stack, variables, and data structures used.

## Common Interview Questions
- Implement a stack using queues. 
- Find the middle element in a linked list. 
- Merge two sorted linked lists. 
- Find the shortest path in a graph. 
- Detect cycles in a graph.

## License
This project is licensed under the MIT License - see the LICENSE file for details.

## Patterns you will see here
1. Two Pointers
2. Binary Search
3. Sliding Window
4. Frequency Counter
5. Multiple Pointers 
6. Divide and Conquer
7. Fast and Slow pointers
8. Merge Intervals
9. Topological sort

Go to my website course: [https://ggorantala.dev](https://ggorantala.dev).